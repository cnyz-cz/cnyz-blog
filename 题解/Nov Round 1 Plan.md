## On Still Water
> 构造一个 $n\times n$ 的 $01$ 矩阵 $a$，满足：
> 	每行恰有 $T$ 个 $1$；
> 	对任意两行 $i,j$，有且只有一个 $k$，满足 $a_{i,k}=a_{j,k}=1$。
> 	每行都是独一无二的。
> 可能无解，$n\le 500$。
> Source：鸭梨 1 月自主测试
## Namid[A]me
> Source：P10083

一个区间可以被打出的条件是：
- 令 $\Delta_i=b_i-a_i$，则 $x=\sum \Delta_i \ge 0$，令 $y=\sum \Delta_i[\Delta_i<0]$；
- $\forall \Delta_i<0, E-a_i+y-\Delta_i\ge 0$；
- $\forall \Delta_i\ge 0,E+y-a_i\ge 0$；

考虑扫描线，对区间右端点向右移动，考虑如果这个右端点 $\Delta <0$，左端点肯定可以往后走，$\Delta>0$，丢掉它对二三两个条件没什么影响。
使用 ST 表分开维护 $\Delta <0$ 的 $b_i$ 最大值，$\Delta>0$ 的 $a_i$ 最大值，即可双指针得到满足 $2,3$ 的最大的 $r$ 的位置，对于条件 $1$ 直接数点即可，$O(n\log n)$，[Code](https://qoj.ac/submission/307493)。
## Milk
> Source：CF2119F

可以这样 claim，我们最终的路径会形如：
- 一条 $1/-1$ 交叉链。
- 在 $1/1$ 之间反复，累计 $S$ 到一定量。
- 走到一个尽量远的地方。
- 在 $1/-1$ 之间反复横跳。

前两者可在一次 BFS 时完成，剩下用一次 DFS，记录下到 $1/1$ 的沿途最短距离，需要加的 $1/1$ 的量，以及当前的权值需求，即可转移。
于是做到 $O(n+m)$。
## November
> Source：P10202

首先说明，问题等价于计算有多少种本质不同的方案使得整个序列被删完，证明省略。
考虑用区间的方式表述这些操作，具体的，忽略删除后的移位操作，将每次删除的左右段点视为一个区间，则一定会有：
- 区间的并是 $[1,n]$。
- 区间之间要么不交，要么包含。
- 对于每一个区间，没被其内部的区间包含的点一定会与该区间操作的颜色相同。

于是尝试 DP，令 $f_{l,r,k}$ 表示 $[l,r]$ 内的覆盖方案个数，要求包含 $[l,r]$，同时需要步数是 $k$ 步，$g_{l,r,k,v}$ 表示 $[l,r]$ 内的一组覆盖方案，不要求包含完 $[l,r]$，但是要求只能剩下至多一种数，且这种数是 $v$，同时需要步数是 $k$ 步。  
容易枚举最右侧的区间来转移，算贡献需要使用组合数，于是可以做到 $O(n^6)$。